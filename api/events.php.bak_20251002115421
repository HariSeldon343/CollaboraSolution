<?php
/**
 * RESTful Calendar Events API for CollaboraNexio
 *
 * Endpoint: /api/events.php
 *
 * Core Endpoints:
 * - GET    /api/events.php?start={date}&end={date}  - Retrieve events in date range
 * - GET    /api/events.php?id={id}                  - Retrieve single event
 * - POST   /api/events.php                          - Create new event
 * - PUT    /api/events.php?id={id}                  - Update existing event
 * - DELETE /api/events.php?id={id}                  - Delete event
 *
 * Additional Actions:
 * - POST   /api/events.php?action=respond&id={id}            - Respond to invitation
 * - GET    /api/events.php?action=conflicts                  - Check scheduling conflicts
 * - GET    /api/events.php?action=availability               - Get user availability
 * - POST   /api/events.php?action=duplicate&id={id}          - Duplicate event
 * - GET    /api/events.php?action=export                     - Export events (iCal)
 * - POST   /api/events.php?action=import                     - Import events (iCal)
 * - GET    /api/events.php?action=suggestions                - Get meeting time suggestions
 * - POST   /api/events.php?action=reschedule&id={id}         - Reschedule with conflict detection
 *
 * @version 1.0.0
 * @since PHP 8.0
 */

declare(strict_types=1);

// Error reporting configuration
error_reporting(E_ALL);
ini_set('display_errors', '0');
ini_set('log_errors', '1');

// Session configuration with security settings
ini_set('session.cookie_httponly', '1');
ini_set('session.cookie_samesite', 'Strict');
ini_set('session.use_only_cookies', '1');
ini_set('session.use_strict_mode', '1');
session_start();

// Required security headers
header('Content-Type: application/json; charset=UTF-8');
header('X-Content-Type-Options: nosniff');
header('X-Frame-Options: DENY');
header('X-XSS-Protection: 1; mode=block');
header('Cache-Control: no-store, no-cache, must-revalidate, private');
header('Strict-Transport-Security: max-age=31536000; includeSubDomains');
header('Referrer-Policy: strict-origin-when-cross-origin');

// CORS headers for cross-origin requests
if (isset($_SERVER['HTTP_ORIGIN'])) {
    header('Access-Control-Allow-Origin: ' . $_SERVER['HTTP_ORIGIN']);
    header('Access-Control-Allow-Credentials: true');
    header('Access-Control-Allow-Methods: GET, POST, PUT, DELETE, OPTIONS');
    header('Access-Control-Allow-Headers: Content-Type, Authorization, X-CSRF-Token');
    header('Access-Control-Max-Age: 86400');
}

// Handle CORS preflight requests
if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') {
    http_response_code(200);
    exit();
}

// Include required files
require_once __DIR__ . '/../config.php';
require_once __DIR__ . '/../includes/db.php';
require_once __DIR__ . '/../includes/auth.php';
require_once __DIR__ . '/../includes/calendar.php';

// Initialize classes
try {
    $db = Database::getInstance()->getConnection();
    $auth = new Auth();

    // Verify authentication
    if (!$auth->isAuthenticated()) {
        sendErrorResponse(401, 'Authentication required');
    }

    $tenant_id = $_SESSION['tenant_id'] ?? null;
    $user_id = $_SESSION['user_id'] ?? null;

    if (!$tenant_id || !$user_id) {
        sendErrorResponse(401, 'Invalid session');
    }

    // Initialize Calendar class
    $calendar = new Calendar($db, $tenant_id, $user_id);

} catch (Exception $e) {
    error_log('API initialization error: ' . $e->getMessage());
    sendErrorResponse(500, 'Server configuration error');
}

/**
 * Send standardized JSON response
 */
function sendResponse(
    bool $success,
    $data,
    string $message,
    int $httpCode = 200,
    array $metadata = []
): void {
    http_response_code($httpCode);

    $response = [
        'success' => $success,
        'data' => $data,
        'message' => $message,
        'metadata' => array_merge([
            'timestamp' => date('c')
        ], $metadata)
    ];

    echo json_encode($response, JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT);
    exit();
}

/**
 * Send error response
 */
function sendErrorResponse(int $httpCode, string $message, $data = null): void {
    sendResponse(false, $data, $message, $httpCode);
}

/**
 * Get JSON request body
 */
function getRequestBody(): array {
    $json = file_get_contents('php://input');
    if (!$json) {
        return [];
    }

    $data = json_decode($json, true);
    if (json_last_error() !== JSON_ERROR_NONE) {
        sendErrorResponse(400, 'Invalid JSON in request body');
    }

    return $data ?? [];
}

/**
 * Validate required parameters
 */
function validateRequiredParams(array $params, array $required): void {
    foreach ($required as $param) {
        if (!isset($params[$param]) || $params[$param] === '') {
            sendErrorResponse(400, "Missing required parameter: $param");
        }
    }
}

/**
 * Validate ISO 8601 date format
 */
function validateDateFormat(string $date): bool {
    $d = DateTime::createFromFormat('Y-m-d\TH:i:sP', $date);
    if (!$d) {
        $d = DateTime::createFromFormat('Y-m-d\TH:i:s\Z', $date);
    }
    if (!$d) {
        $d = DateTime::createFromFormat('Y-m-d', $date);
    }
    return $d && $d->format('Y-m-d') === explode('T', $date)[0];
}

/**
 * Parse and validate date parameter
 */
function parseDate(string $dateStr): DateTime {
    try {
        return new DateTime($dateStr);
    } catch (Exception $e) {
        sendErrorResponse(400, "Invalid date format: $dateStr");
    }
}

// Route request based on method and action
$method = $_SERVER['REQUEST_METHOD'];
$action = $_GET['action'] ?? null;
$id = isset($_GET['id']) ? intval($_GET['id']) : null;

try {
    switch ($method) {
        case 'GET':
            handleGetRequest($calendar, $action, $id);
            break;

        case 'POST':
            handlePostRequest($calendar, $action, $id);
            break;

        case 'PUT':
            handlePutRequest($calendar, $id);
            break;

        case 'DELETE':
            handleDeleteRequest($calendar, $id);
            break;

        default:
            sendErrorResponse(405, 'Method not allowed');
    }
} catch (Exception $e) {
    error_log('API error: ' . $e->getMessage());
    sendErrorResponse(500, 'Server error: ' . $e->getMessage());
}

/**
 * Handle GET requests
 */
function handleGetRequest(Calendar $calendar, ?string $action, ?int $id): void {
    global $user_id;

    // Handle special actions
    if ($action) {
        switch ($action) {
            case 'conflicts':
                handleCheckConflicts($calendar);
                break;

            case 'availability':
                handleGetAvailability($calendar);
                break;

            case 'export':
                handleExportEvents($calendar);
                break;

            case 'suggestions':
                handleGetSuggestions($calendar);
                break;

            default:
                sendErrorResponse(400, "Unknown action: $action");
        }
        return;
    }

    // Get single event by ID
    if ($id) {
        $event = getEventById($calendar, $id);
        if (!$event) {
            sendErrorResponse(404, 'Event not found');
        }

        sendResponse(true, $event, 'Event retrieved successfully');
        return;
    }

    // Get events in date range
    $start = $_GET['start'] ?? null;
    $end = $_GET['end'] ?? null;

    if (!$start || !$end) {
        sendErrorResponse(400, 'Missing required parameters: start and end dates');
    }

    // Validate date formats
    if (!validateDateFormat($start) || !validateDateFormat($end)) {
        sendErrorResponse(400, 'Invalid date format. Use ISO 8601 format');
    }

    $startDate = parseDate($start);
    $endDate = parseDate($end);

    if ($startDate > $endDate) {
        sendErrorResponse(400, 'Start date must be before end date');
    }

    // Build filters
    $filters = [];

    if (isset($_GET['calendar_id'])) {
        $filters['calendar_id'] = intval($_GET['calendar_id']);
    }

    if (isset($_GET['participant_id'])) {
        $filters['user_id'] = intval($_GET['participant_id']);
    }

    if (isset($_GET['category'])) {
        $filters['category'] = $_GET['category'];
    }

    if (isset($_GET['location'])) {
        $filters['location'] = $_GET['location'];
    }

    // Get events
    $events = $calendar->getEventsBetween($startDate, $endDate, $filters);

    // Apply timezone conversion if requested
    if (isset($_GET['timezone'])) {
        $timezone = new DateTimeZone($_GET['timezone']);
        foreach ($events as &$event) {
            $event['start_date_local'] = convertToTimezone($event['start_date'], $timezone);
            $event['end_date_local'] = convertToTimezone($event['end_date'], $timezone);
        }
    }

    // Include recurring events expansion (default: true)
    $includeRecurring = filter_var($_GET['include_recurring'] ?? true, FILTER_VALIDATE_BOOLEAN);
    if (!$includeRecurring) {
        $events = array_filter($events, fn($e) => !($e['is_recurring_instance'] ?? false));
    }

    // Format response
    $responseData = [
        'events' => $events,
        'total' => count($events)
    ];

    $metadata = [
        'start' => $start,
        'end' => $end,
        'filters_applied' => count($filters) > 0
    ];

    sendResponse(true, $responseData, 'Events retrieved successfully', 200, $metadata);
}

/**
 * Handle POST requests
 */
function handlePostRequest(Calendar $calendar, ?string $action, ?int $id): void {
    // Handle special actions
    if ($action) {
        switch ($action) {
            case 'respond':
                if (!$id) {
                    sendErrorResponse(400, 'Event ID required');
                }
                handleRespondToInvitation($calendar, $id);
                break;

            case 'duplicate':
                if (!$id) {
                    sendErrorResponse(400, 'Event ID required');
                }
                handleDuplicateEvent($calendar, $id);
                break;

            case 'import':
                handleImportEvents($calendar);
                break;

            case 'reschedule':
                if (!$id) {
                    sendErrorResponse(400, 'Event ID required');
                }
                handleRescheduleEvent($calendar, $id);
                break;

            default:
                sendErrorResponse(400, "Unknown action: $action");
        }
        return;
    }

    // Create new event
    $data = getRequestBody();

    // Validate required fields
    validateRequiredParams($data, ['title', 'start', 'end']);

    // Validate dates
    if (!validateDateFormat($data['start']) || !validateDateFormat($data['end'])) {
        sendErrorResponse(400, 'Invalid date format. Use ISO 8601 format');
    }

    $startDate = parseDate($data['start']);
    $endDate = parseDate($data['end']);

    if ($startDate >= $endDate) {
        sendErrorResponse(400, 'End date must be after start date');
    }

    // Prepare event data for Calendar class
    $eventData = [
        'title' => $data['title'],
        'description' => $data['description'] ?? null,
        'start_date' => $startDate->format('Y-m-d H:i:s'),
        'end_date' => $endDate->format('Y-m-d H:i:s'),
        'timezone' => $data['timezone'] ?? date_default_timezone_get(),
        'all_day' => $data['is_all_day'] ?? false,
        'location' => $data['location'] ?? null,
        'calendar_id' => $data['calendar_id'] ?? null,
        'category' => validateCategory($data['category'] ?? 'meeting'),
        'status' => 'confirmed',
        'visibility' => validateVisibility($data['visibility'] ?? 'private'),
        'check_conflicts' => true
    ];

    // Handle recurrence
    if (isset($data['recurrence']) && !empty($data['recurrence'])) {
        $eventData['recurrence_rule'] = $data['recurrence'];

        // Validate RRULE format
        try {
            $calendar->parseRecurrenceRule($data['recurrence']);
        } catch (Exception $e) {
            sendErrorResponse(400, 'Invalid recurrence rule: ' . $e->getMessage());
        }
    }

    // Add optional fields
    if (isset($data['color']) && preg_match('/^#[0-9A-Fa-f]{6}$/', $data['color'])) {
        $eventData['color'] = $data['color'];
    }

    // Handle participants
    $participants = [];
    if (isset($data['participants']) && is_array($data['participants'])) {
        foreach ($data['participants'] as $participant) {
            if (isset($participant['user_id'])) {
                $participants[] = intval($participant['user_id']);
            } elseif (isset($participant['email'])) {
                // Handle external participants by email
                $externalUserId = getOrCreateExternalUser($participant['email']);
                if ($externalUserId) {
                    $participants[] = $externalUserId;
                }
            }
        }
        $eventData['participants'] = $participants;
    }

    // Handle reminders
    if (isset($data['reminders']) && is_array($data['reminders'])) {
        $eventData['reminders'] = $data['reminders'];
    }

    // Handle attachments
    if (isset($data['attachments']) && is_array($data['attachments'])) {
        $eventData['attachments'] = array_map('intval', $data['attachments']);
    }

    // Create event
    try {
        $eventId = $calendar->createEvent($eventData);

        // Get created event
        $createdEvent = getEventById($calendar, $eventId);

        $message = 'Event created successfully';
        if (!empty($participants)) {
            $message .= ' and invitations sent';
        }

        sendResponse(true, $createdEvent, $message, 201);

    } catch (RuntimeException $e) {
        if (strpos($e->getMessage(), 'Conflitti rilevati') !== false) {
            // Parse conflicts from error message
            $conflictsJson = substr($e->getMessage(), strpos($e->getMessage(), '{'));
            $conflicts = json_decode($conflictsJson, true);

            sendErrorResponse(409, 'Scheduling conflicts detected', [
                'conflicts' => $conflicts
            ]);
        } else {
            throw $e;
        }
    }
}

/**
 * Handle PUT requests
 */
function handlePutRequest(Calendar $calendar, ?int $id): void {
    if (!$id) {
        sendErrorResponse(400, 'Event ID required');
    }

    // Check if event exists
    $existingEvent = getEventById($calendar, $id);
    if (!$existingEvent) {
        sendErrorResponse(404, 'Event not found');
    }

    $data = getRequestBody();

    if (empty($data)) {
        sendErrorResponse(400, 'No data provided for update');
    }

    // Prepare update data
    $updateData = [];

    // Update basic fields if provided
    $allowedFields = [
        'title', 'description', 'location', 'category',
        'color', 'visibility', 'status', 'timezone'
    ];

    foreach ($allowedFields as $field) {
        if (isset($data[$field])) {
            $updateData[$field] = $data[$field];
        }
    }

    // Handle date updates
    if (isset($data['start'])) {
        if (!validateDateFormat($data['start'])) {
            sendErrorResponse(400, 'Invalid start date format');
        }
        $updateData['start_date'] = parseDate($data['start'])->format('Y-m-d H:i:s');
    }

    if (isset($data['end'])) {
        if (!validateDateFormat($data['end'])) {
            sendErrorResponse(400, 'Invalid end date format');
        }
        $updateData['end_date'] = parseDate($data['end'])->format('Y-m-d H:i:s');
    }

    if (isset($data['is_all_day'])) {
        $updateData['all_day'] = filter_var($data['is_all_day'], FILTER_VALIDATE_BOOLEAN);
    }

    // Handle recurrence update
    if (array_key_exists('recurrence', $data)) {
        if (!empty($data['recurrence'])) {
            try {
                $calendar->parseRecurrenceRule($data['recurrence']);
                $updateData['recurrence_rule'] = $data['recurrence'];
            } catch (Exception $e) {
                sendErrorResponse(400, 'Invalid recurrence rule: ' . $e->getMessage());
            }
        } else {
            $updateData['recurrence_rule'] = null;
        }
    }

    // Check for conflicts if dates changed
    $checkConflicts = !isset($_GET['notify_participants']) ||
                      filter_var($_GET['notify_participants'], FILTER_VALIDATE_BOOLEAN);
    $updateData['check_conflicts'] = $checkConflicts;

    // Handle participants update
    if (isset($data['participants'])) {
        $participants = [];
        foreach ($data['participants'] as $participant) {
            if (isset($participant['user_id'])) {
                $participants[] = intval($participant['user_id']);
            }
        }
        $updateData['participants'] = $participants;
    }

    // Handle reminders update
    if (isset($data['reminders'])) {
        $updateData['reminders'] = $data['reminders'];
    }

    // Update event
    try {
        $success = $calendar->updateEvent($id, $updateData);

        if ($success) {
            // Get updated event
            $updatedEvent = getEventById($calendar, $id);

            $message = 'Event updated successfully';
            if ($checkConflicts) {
                $message .= ' and participants notified';
            }

            sendResponse(true, $updatedEvent, $message);
        } else {
            sendErrorResponse(500, 'Failed to update event');
        }

    } catch (RuntimeException $e) {
        if (strpos($e->getMessage(), 'Conflitti rilevati') !== false) {
            // Parse conflicts
            $conflictsJson = substr($e->getMessage(), strpos($e->getMessage(), '{'));
            $conflicts = json_decode($conflictsJson, true);

            sendErrorResponse(409, 'Scheduling conflicts detected', [
                'conflicts' => $conflicts
            ]);
        } else if (strpos($e->getMessage(), 'Permessi insufficienti') !== false) {
            sendErrorResponse(403, 'Insufficient permissions to modify event');
        } else {
            throw $e;
        }
    }
}

/**
 * Handle DELETE requests
 */
function handleDeleteRequest(Calendar $calendar, ?int $id): void {
    if (!$id) {
        sendErrorResponse(400, 'Event ID required');
    }

    // Check if event exists
    $event = getEventById($calendar, $id);
    if (!$event) {
        sendErrorResponse(404, 'Event not found');
    }

    // Check for delete_series parameter for recurring events
    $deleteSeries = filter_var($_GET['delete_series'] ?? false, FILTER_VALIDATE_BOOLEAN);
    $notifyParticipants = filter_var($_GET['notify_participants'] ?? true, FILTER_VALIDATE_BOOLEAN);

    try {
        // Handle recurring series deletion
        if ($deleteSeries && $event['is_recurring']) {
            // Delete all instances of recurring event
            $success = deleteRecurringSeries($calendar, $id, $notifyParticipants);
        } else {
            // Delete single event
            $success = $calendar->deleteEvent($id, $notifyParticipants);
        }

        if ($success) {
            $message = 'Event cancelled';
            if ($notifyParticipants) {
                $message .= ' and participants notified';
            }

            sendResponse(true, null, $message);
        } else {
            sendErrorResponse(500, 'Failed to delete event');
        }

    } catch (RuntimeException $e) {
        if (strpos($e->getMessage(), 'Permessi insufficienti') !== false) {
            sendErrorResponse(403, 'Insufficient permissions to delete event');
        } else {
            throw $e;
        }
    }
}

/**
 * Handle respond to invitation
 */
function handleRespondToInvitation(Calendar $calendar, int $eventId): void {
    global $db, $tenant_id, $user_id;

    $data = getRequestBody();
    validateRequiredParams($data, ['response']);

    $validResponses = ['accepted', 'declined', 'tentative'];
    if (!in_array($data['response'], $validResponses)) {
        sendErrorResponse(400, 'Invalid response. Must be: accepted, declined, or tentative');
    }

    try {
        // Update participant response
        $sql = "UPDATE event_participants
                SET status = :status,
                    responded_at = NOW(),
                    response_message = :message
                WHERE event_id = :event_id
                  AND user_id = :user_id
                  AND event_id IN (
                      SELECT id FROM events WHERE tenant_id = :tenant_id
                  )";

        $stmt = $db->prepare($sql);
        $result = $stmt->execute([
            ':status' => $data['response'],
            ':message' => $data['message'] ?? null,
            ':event_id' => $eventId,
            ':user_id' => $user_id,
            ':tenant_id' => $tenant_id
        ]);

        if ($stmt->rowCount() === 0) {
            sendErrorResponse(404, 'Invitation not found or already responded');
        }

        // Log response
        $calendar->logActivity('event_response', $eventId, [
            'user_id' => $user_id,
            'response' => $data['response'],
            'message' => $data['message'] ?? null
        ]);

        sendResponse(true, null, 'Response recorded successfully');

    } catch (Exception $e) {
        error_log('Error responding to invitation: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to record response');
    }
}

/**
 * Handle check conflicts
 */
function handleCheckConflicts(Calendar $calendar): void {
    validateRequiredParams($_GET, ['start', 'end']);

    $startDate = parseDate($_GET['start']);
    $endDate = parseDate($_GET['end']);

    // Get participants list
    $participants = [];
    if (isset($_GET['participants']) && is_array($_GET['participants'])) {
        $participants = array_map('intval', $_GET['participants']);
    }

    try {
        $conflicts = $calendar->detectConflicts($startDate, $endDate, $participants);

        $responseData = [
            'has_conflicts' => !empty($conflicts),
            'conflicts' => $conflicts,
            'total' => count($conflicts)
        ];

        sendResponse(true, $responseData,
            empty($conflicts) ? 'No conflicts found' : 'Conflicts detected');

    } catch (Exception $e) {
        error_log('Error checking conflicts: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to check conflicts');
    }
}

/**
 * Handle get availability
 */
function handleGetAvailability(Calendar $calendar): void {
    validateRequiredParams($_GET, ['user_id', 'date']);

    $userId = intval($_GET['user_id']);
    $date = parseDate($_GET['date']);

    try {
        $availability = $calendar->getUserAvailability($userId, $date);

        sendResponse(true, $availability, 'Availability retrieved successfully');

    } catch (Exception $e) {
        error_log('Error getting availability: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to get availability');
    }
}

/**
 * Handle export events
 */
function handleExportEvents(Calendar $calendar): void {
    validateRequiredParams($_GET, ['start', 'end']);

    $format = $_GET['format'] ?? 'ics';
    if ($format !== 'ics') {
        sendErrorResponse(400, 'Unsupported export format. Only iCalendar (ics) is supported');
    }

    $startDate = parseDate($_GET['start']);
    $endDate = parseDate($_GET['end']);

    // Apply filters
    $filters = [];
    if (isset($_GET['calendar_id'])) {
        $filters['calendar_id'] = intval($_GET['calendar_id']);
    }
    if (isset($_GET['category'])) {
        $filters['category'] = $_GET['category'];
    }

    try {
        // Get events
        $events = $calendar->getEventsBetween($startDate, $endDate, $filters);

        // Generate iCalendar content
        $icsContent = $calendar->exportToICS($events);

        // Set headers for file download
        header('Content-Type: text/calendar; charset=utf-8');
        header('Content-Disposition: attachment; filename="calendar_export.ics"');
        header('Content-Length: ' . strlen($icsContent));

        echo $icsContent;
        exit();

    } catch (Exception $e) {
        error_log('Error exporting events: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to export events');
    }
}

/**
 * Handle import events
 */
function handleImportEvents(Calendar $calendar): void {
    $data = getRequestBody();

    // Check for file upload
    if (isset($_FILES['ics_file'])) {
        if ($_FILES['ics_file']['error'] !== UPLOAD_ERR_OK) {
            sendErrorResponse(400, 'File upload failed');
        }

        $icsData = file_get_contents($_FILES['ics_file']['tmp_name']);
    } elseif (isset($data['ics_data'])) {
        $icsData = $data['ics_data'];
    } else {
        sendErrorResponse(400, 'No iCalendar data provided');
    }

    try {
        $result = $calendar->importFromICS($icsData);

        $message = sprintf(
            'Import completed. %d events imported, %d errors',
            count($result['imported']),
            count($result['errors'])
        );

        sendResponse(
            count($result['errors']) === 0,
            $result,
            $message,
            count($result['errors']) > 0 ? 207 : 201
        );

    } catch (Exception $e) {
        error_log('Error importing events: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to import events: ' . $e->getMessage());
    }
}

/**
 * Handle get meeting suggestions
 */
function handleGetSuggestions(Calendar $calendar): void {
    validateRequiredParams($_GET, ['duration', 'date_range_start', 'date_range_end']);

    $duration = intval($_GET['duration']);
    if ($duration < 15 || $duration > 480) {
        sendErrorResponse(400, 'Duration must be between 15 and 480 minutes');
    }

    $participants = [];
    if (isset($_GET['participants']) && is_array($_GET['participants'])) {
        $participants = array_map('intval', $_GET['participants']);
    }

    if (empty($participants)) {
        sendErrorResponse(400, 'At least one participant required');
    }

    $dateRange = [
        'start' => $_GET['date_range_start'],
        'end' => $_GET['date_range_end']
    ];

    // Parse preferences
    $preferences = [];
    if (isset($_GET['preferred_times'])) {
        $preferences['preferred_times'] = $_GET['preferred_times'];
    }
    if (isset($_GET['avoid_lunch'])) {
        $preferences['avoid_lunch'] = filter_var($_GET['avoid_lunch'], FILTER_VALIDATE_BOOLEAN);
    }
    if (isset($_GET['skip_weekends'])) {
        $preferences['skip_weekends'] = filter_var($_GET['skip_weekends'], FILTER_VALIDATE_BOOLEAN);
    }
    if (isset($_GET['max_suggestions'])) {
        $preferences['max_suggestions'] = intval($_GET['max_suggestions']);
    }

    try {
        $suggestions = $calendar->suggestFreeSlots(
            $duration,
            $participants,
            $dateRange,
            $preferences
        );

        $responseData = [
            'suggestions' => $suggestions,
            'total' => count($suggestions),
            'parameters' => [
                'duration' => $duration,
                'participants' => $participants,
                'date_range' => $dateRange,
                'preferences' => $preferences
            ]
        ];

        sendResponse(true, $responseData, 'Meeting suggestions generated successfully');

    } catch (Exception $e) {
        error_log('Error generating suggestions: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to generate suggestions');
    }
}

/**
 * Handle duplicate event
 */
function handleDuplicateEvent(Calendar $calendar, int $eventId): void {
    global $db, $tenant_id;

    $data = getRequestBody();

    // Get original event
    $originalEvent = getEventById($calendar, $eventId);
    if (!$originalEvent) {
        sendErrorResponse(404, 'Event not found');
    }

    // Prepare duplicate data
    $duplicateData = [
        'title' => $data['title'] ?? $originalEvent['title'] . ' (Copy)',
        'description' => $data['description'] ?? $originalEvent['description'],
        'location' => $data['location'] ?? $originalEvent['location'],
        'category' => $originalEvent['category'],
        'color' => $originalEvent['color'],
        'visibility' => $originalEvent['visibility'],
        'all_day' => $originalEvent['all_day']
    ];

    // Handle new dates
    if (isset($data['start']) && isset($data['end'])) {
        $duplicateData['start_date'] = parseDate($data['start'])->format('Y-m-d H:i:s');
        $duplicateData['end_date'] = parseDate($data['end'])->format('Y-m-d H:i:s');
    } else {
        // Use original dates
        $duplicateData['start_date'] = $originalEvent['start_date'];
        $duplicateData['end_date'] = $originalEvent['end_date'];
    }

    // Copy participants if requested
    if (filter_var($data['copy_participants'] ?? false, FILTER_VALIDATE_BOOLEAN)) {
        $duplicateData['participants'] = array_map(
            fn($p) => $p['user_id'],
            $originalEvent['participants'] ?? []
        );
    }

    // Copy reminders if requested
    if (filter_var($data['copy_reminders'] ?? true, FILTER_VALIDATE_BOOLEAN)) {
        $duplicateData['reminders'] = $originalEvent['reminders'] ?? [];
    }

    try {
        $newEventId = $calendar->createEvent($duplicateData);
        $newEvent = getEventById($calendar, $newEventId);

        sendResponse(true, $newEvent, 'Event duplicated successfully', 201);

    } catch (Exception $e) {
        error_log('Error duplicating event: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to duplicate event');
    }
}

/**
 * Handle reschedule event
 */
function handleRescheduleEvent(Calendar $calendar, int $eventId): void {
    $data = getRequestBody();
    validateRequiredParams($data, ['start', 'end']);

    $newStart = parseDate($data['start']);
    $newEnd = parseDate($data['end']);

    if ($newStart >= $newEnd) {
        sendErrorResponse(400, 'End date must be after start date');
    }

    // Get current event
    $event = getEventById($calendar, $eventId);
    if (!$event) {
        sendErrorResponse(404, 'Event not found');
    }

    // Check for conflicts with new time
    $participants = array_map(fn($p) => $p['user_id'], $event['participants'] ?? []);
    $conflicts = $calendar->detectConflicts($newStart, $newEnd, $participants);

    // Remove current event from conflicts
    $conflicts = array_filter($conflicts, fn($c) => $c['event_id'] != $eventId);

    if (!empty($conflicts) && !filter_var($data['force'] ?? false, FILTER_VALIDATE_BOOLEAN)) {
        sendErrorResponse(409, 'Conflicts detected at new time', [
            'conflicts' => $conflicts,
            'suggestion' => 'Set force=true to reschedule anyway'
        ]);
    }

    // Reschedule event
    $updateData = [
        'start_date' => $newStart->format('Y-m-d H:i:s'),
        'end_date' => $newEnd->format('Y-m-d H:i:s'),
        'check_conflicts' => false
    ];

    try {
        $success = $calendar->updateEvent($eventId, $updateData);

        if ($success) {
            $updatedEvent = getEventById($calendar, $eventId);

            $message = 'Event rescheduled successfully';
            if (!empty($conflicts)) {
                $message .= ' (conflicts overridden)';
            }

            sendResponse(true, $updatedEvent, $message);
        } else {
            sendErrorResponse(500, 'Failed to reschedule event');
        }

    } catch (Exception $e) {
        error_log('Error rescheduling event: ' . $e->getMessage());
        sendErrorResponse(500, 'Failed to reschedule event');
    }
}

// ========== Helper Functions ==========

/**
 * Get event by ID with full details
 */
function getEventById(Calendar $calendar, int $id): ?array {
    global $db, $tenant_id;

    try {
        $sql = "SELECT e.*,
                       u.name as creator_name,
                       u.email as creator_email,
                       cal.name as calendar_name,
                       cal.color as calendar_color
                FROM events e
                LEFT JOIN users u ON e.created_by = u.id
                LEFT JOIN calendars cal ON e.calendar_id = cal.id
                WHERE e.id = :id
                  AND e.tenant_id = :tenant_id
                  AND e.deleted_at IS NULL";

        $stmt = $db->prepare($sql);
        $stmt->execute([
            ':id' => $id,
            ':tenant_id' => $tenant_id
        ]);

        $event = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$event) {
            return null;
        }

        // Format event data
        $formatted = [
            'id' => $event['id'],
            'title' => $event['title'],
            'description' => $event['description'],
            'start' => formatDateISO($event['start_date']),
            'end' => formatDateISO($event['end_date']),
            'is_all_day' => (bool)$event['all_day'],
            'location' => $event['location'],
            'calendar' => $event['calendar_id'] ? [
                'id' => $event['calendar_id'],
                'name' => $event['calendar_name'],
                'color' => $event['calendar_color'] ?? $event['color']
            ] : null,
            'participants' => getEventParticipants($id),
            'recurrence' => $event['recurrence_rule'] ? [
                'pattern' => $event['recurrence_rule'],
                'is_recurring' => true,
                'parent_id' => $event['parent_event_id']
            ] : null,
            'reminders' => getEventReminders($id),
            'category' => $event['category'],
            'status' => $event['status'],
            'can_edit' => canEditEvent($event)
        ];

        return $formatted;

    } catch (Exception $e) {
        error_log('Error getting event: ' . $e->getMessage());
        return null;
    }
}

/**
 * Get event participants
 */
function getEventParticipants(int $eventId): array {
    global $db, $tenant_id;

    try {
        $sql = "SELECT ep.*, u.name, u.email
                FROM event_participants ep
                JOIN users u ON ep.user_id = u.id
                WHERE ep.event_id = :event_id
                  AND u.tenant_id = :tenant_id";

        $stmt = $db->prepare($sql);
        $stmt->execute([
            ':event_id' => $eventId,
            ':tenant_id' => $tenant_id
        ]);

        $participants = [];
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $participants[] = [
                'user_id' => $row['user_id'],
                'name' => $row['name'],
                'email' => $row['email'],
                'status' => $row['status'],
                'is_organizer' => (bool)$row['is_organizer'],
                'responded_at' => $row['responded_at']
            ];
        }

        return $participants;

    } catch (Exception $e) {
        error_log('Error getting participants: ' . $e->getMessage());
        return [];
    }
}

/**
 * Get event reminders
 */
function getEventReminders(int $eventId): array {
    global $db;

    try {
        $sql = "SELECT type, minutes_before
                FROM event_reminders
                WHERE event_id = :event_id
                ORDER BY minutes_before ASC";

        $stmt = $db->prepare($sql);
        $stmt->execute([':event_id' => $eventId]);

        $reminders = [];
        while ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {
            $reminders[] = [
                'type' => $row['type'],
                'minutes_before' => intval($row['minutes_before'])
            ];
        }

        return $reminders;

    } catch (Exception $e) {
        error_log('Error getting reminders: ' . $e->getMessage());
        return [];
    }
}

/**
 * Delete recurring series
 */
function deleteRecurringSeries(Calendar $calendar, int $parentId, bool $notify): bool {
    global $db, $tenant_id;

    try {
        // Find all instances
        $sql = "SELECT id FROM events
                WHERE (id = :id OR parent_event_id = :id)
                  AND tenant_id = :tenant_id";

        $stmt = $db->prepare($sql);
        $stmt->execute([
            ':id' => $parentId,
            ':tenant_id' => $tenant_id
        ]);

        $eventIds = $stmt->fetchAll(PDO::FETCH_COLUMN);

        // Delete each instance
        foreach ($eventIds as $eventId) {
            $calendar->deleteEvent($eventId, $notify);
        }

        return true;

    } catch (Exception $e) {
        error_log('Error deleting series: ' . $e->getMessage());
        return false;
    }
}

/**
 * Get or create external user
 */
function getOrCreateExternalUser(string $email): ?int {
    global $db, $tenant_id;

    try {
        // Check if user exists
        $sql = "SELECT id FROM users
                WHERE email = :email AND tenant_id = :tenant_id";

        $stmt = $db->prepare($sql);
        $stmt->execute([
            ':email' => $email,
            ':tenant_id' => $tenant_id
        ]);

        $userId = $stmt->fetchColumn();

        if ($userId) {
            return intval($userId);
        }

        // Create external user
        $sql = "INSERT INTO users (tenant_id, email, name, role, is_external, created_at)
                VALUES (:tenant_id, :email, :name, 'external', TRUE, NOW())";

        $stmt = $db->prepare($sql);
        $stmt->execute([
            ':tenant_id' => $tenant_id,
            ':email' => $email,
            ':name' => explode('@', $email)[0]
        ]);

        return intval($db->lastInsertId());

    } catch (Exception $e) {
        error_log('Error creating external user: ' . $e->getMessage());
        return null;
    }
}

/**
 * Check if user can edit event
 */
function canEditEvent(array $event): bool {
    global $user_id;

    return $event['created_by'] == $user_id ||
           $_SESSION['role'] === 'admin' ||
           $_SESSION['role'] === 'super_admin';
}

/**
 * Format date to ISO 8601
 */
function formatDateISO(string $date): string {
    $dt = new DateTime($date);
    return $dt->format('c');
}

/**
 * Convert date to timezone
 */
function convertToTimezone(string $date, DateTimeZone $timezone): string {
    $dt = new DateTime($date);
    $dt->setTimezone($timezone);
    return $dt->format('c');
}

/**
 * Validate category
 */
function validateCategory(string $category): string {
    $validCategories = ['meeting', 'task', 'reminder', 'review', 'holiday', 'other'];
    return in_array($category, $validCategories) ? $category : 'meeting';
}

/**
 * Validate visibility
 */
function validateVisibility(string $visibility): string {
    $validVisibility = ['private', 'public', 'team'];
    return in_array($visibility, $validVisibility) ? $visibility : 'private';
}

// End of file